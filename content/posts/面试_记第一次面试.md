---
# 主页简介
# summary: ""
# 文章副标题
# subtitle: ""
# 作者信息
# author: ""
# authorLink: ""
# authorEmail: ""
# description: ""
# keywords: ""
# license: ""
# images: []
# 文章的特色图片
# featuredImage: ""
# 用在主页预览的文章特色图片
# featuredImagePreview: ""
# password:加密页面内容的密码，详见 主题文档 - 内容加密
# message:  加密提示信息，详见 主题文档 - 内容加密
linkToMarkdown: false
# 上面一般不用动
title: "记第一次面试"
date: 2023-06-16T02:30:45+08:00
lastmod: 2023-06-16T02:30:45+08:00
categories: ["面试"]
tags: []
---

人生第一次面试，有点小慌。以至于忘记打开录音设备。下面是回忆的一些内容（有一些比较简单的就没列进来啦）。

对方是北京一个只有 10 个人的初创团队，主要产品是低代码开发平台的研发，在 GitHub 开源。

面了大概有 46 分钟，面试官全程很严肃，有点压抑。面试官没说结果，HR 也没说，估计挂了。

## 面试过程

### 自我介绍

* 自我介绍

  **我**：我是来自华侨大学软件工程的一名学生，我觉得我的个人优势是经常读一些计算机基础书籍，基础知识扎实。  
  
  **面试官**：额，“挺简单的”。（具体用哪个词忘记了，就是说我自我介绍太短了）

  {{< admonition info "面后复习反思" true >}}
  自我介绍要提前准备好，多准备一点。可以说平时读书，先修了核心课程，已修完数据结构，操作系统，计网，数据库（因为我发现面试官还问我数据机构修了么这种问题，显然已经忘记大学的课程安排，因为我是准大三，所以告诉他我已经修完核心课程）。其他的，等考试完再来增添把，形成统一回答把。
  {{< /admonition >}}

### 项目

* 你的定时器项目的架构是怎么样的？（一来就问项目）

  （说得不好，慌了，最后圆回去了，但是很扣分我觉得）  
  他还说谷歌的哪一个定时器（我问 ChatGPA 说是 Google Cloud Scheduler）做得特别好，叫我可以去看看。

  {{< admonition info "面后复习反思" true >}}
  考试后补上把
  {{< /admonition >}}

* 能够支持多少台机器的并发（指的是分布式定时器的机器数量）？  
  **我**：（想了一下）并发主要是由时间二维分片的分桶数量决定的

  {{< admonition info "面后复习反思" true >}}
  需要从两方面考虑
  1. 我采用的是轮询的方式，所以对于 redis 分布式锁的访问量是很高的，所以可能在 redis 出现瓶颈
  2. 第二个就是我说的由时间二维分片的分桶数量决定的，就是说同一个时间需要的作业批数就那么多，再加机器也没有用，所以，需要增加二维分桶的数量（其实这个本来在设计的时候也很大，所以面试官应该想要的回答是 1. 中的 redis 问题）
  {{< /admonition >}}

* schedule 如何负载均衡？

  **我**：通过分布式锁的抢占（轮询）获取作业权利
  
  **面试官**：分布式锁的 key？

  **我**：时间_时间内分桶序号

  **面试官**：分布式锁采用轮询的方式，会不会打绷掉 redis

  **我**：确实，这个是这个项目的缺陷。（其实我在做这个项目的时候有想过这个问题，但是没想过解决！！！）

  **面试官**：那如何解决（。。。）

  {{< admonition info "面后复习反思" true >}}
  考试后补上把
  {{< /admonition >}}

* 前端过来的请求如何到集群中？
 
  **我**：（其实问的也是负载均衡，但是我没实现。。。）

  {{< admonition info "面后复习反思" true >}}
  通过 nginx 反向代理的同时进行负载均衡到每个机器 webserver 中
  {{< /admonition >}}

* 问我 mit6.824 是不是还没学？

  我说没有。（唉，现在这么卷么，mit6.824 已经成标配了么，我就在牛客经常刷过，对这个课有印象。）

### Go 基础

* array 和 slice 的区别

  **我**：array 是静态的，slice 是动态的，内部封装了 array。

  **面试官**：slice 的底层结构是什么

  **我**：length，cap，array（！！！）

  **面试官**：那两者传参后在函数内部修改会影响到原来的么

  **我**：go 都是值传递，array 不能，slice 的话。。。。。（讲了很多）

  **面试官**：那 slice 内部的 array 是指针还是单纯一个数组

  **我**：指针

  **面试**：我就想听这个，你说这个，传参后面说那么多就不用说了。（就是说我回答不到重点！！！）

  {{< admonition info "面后复习反思" true >}}
  array 和 slice 差异：
  * 数组，[const]int，必须是常量，在编译时就确认的了。是静态的，是不会改变大小的
  * slice，内部有 length、cap、unsafe.Pointer（指向 array），是动态的，可以调整大小
  传参：（Go 是值传递）
  * 数组：值传递，传递会 copy 整个数组，不能修改到外部
  * slice：值传递会 copy slice struct，由于只要不进行扩容，函数的 slice struct 和函数外部的 slice struct 是同一个地址，指向同一个 array，所以能改变。如果函数内扩容了，那么 point 会赋值一个新的 array 地址，就不会修改到外面。（想到修改到外面，需要函数参数为 *[]int，即会 copy slice struct 的地址，这样内外都是同一个 slice struct，随便怎么扩容和修改）

  差异回答太简单了！！！要像上面回答。而且传参部分没讲好，一定要停顿思考以下，先整理清楚再回答。
  {{< /admonition >}}

* new 和 make 的区别

  **我**：（这个会）

  {{< admonition info "面后复习反思" true >}}
  * make 只能用于 slice，map 和 chanel（只有三种），会初始化内部深一层的内存空间
  * new 适用于任何类型，内存空间置零值
  {{< /admonition >}}
  
* map 是并发安全的么，不是，有什么方法并发安全

  **我**：加互斥锁，或者直接使用 sync.Map

  **面试官**：还有其他方法么

  **我**：我想了一会，沉默

  **面试官**：如果没接触过就下一个问题把。

  **面试官**：map 如何解决哈希冲突

  **我**：链接地址法（讲歪了，应该是拉链法法，面试官还问数据结构是哪本教材，他建议读读国外的教材，命名比较规范，其实是我讲歪了哈哈），通过在后方直接链接一个链表。
  
  **面试官**：map 的扩容机制

  **我**：等量扩容（负载因子 6），等量扩容（这里我是懂的，但是没能讲清楚）
  
  **面试官**：我说得有点多。。。
  （复盘时突然顿悟：他应该想要的答案是**渐进式扩容**，唉，我也是知道的，但是没回答到点子上，后面要多多揣摩出题人的出题目的啊啊啊）

  {{< admonition info "面后复习反思" true >}}
  1. 如果真的完全不知道的题目： 直接说不知道  
  2. Go map 并发安全方法
    1. 互斥锁  
    2. 读写锁  
    3. sync.Map  
    4. 分段锁（可能面试官是想问这个？）  
  3. map 如何解决哈希冲突
    拉链法，**相同的通过链表存储再后面**（重点再后面）
  5. map 的扩容机制（渐进式扩容）
    * 翻倍扩容（负载因子 > 6.5）
    * 等量扩容
       * 如果**常规桶数目**不大于 2^15，那么使用的溢出桶数目超过常规桶就算是多了
       * 如果常规桶数目大于 2^15，那么使用溢出桶数目一旦超过 2^15 就算多了
  {{< /admonition >}}

* 读写锁是什么

  **我**：读并发，写互斥

  因为我论述过于简单，后面还问了一些情况。eg：写的时候允许读不？

  {{< admonition info "面后复习反思" true >}}
  讲一下互斥锁：
  * 读并发，写互斥，写的时候不允许读（最后一句是关键（是面试官想问的），虽然这个我是知道的，但是没说出来，说明不能理解考题的关键，要学会揣摩考题）  
  * 适用场景：读多写少的情况
  {{< /admonition >}}

* sync.Map 的底层结构
  
  **我**：（这个会）

  **面试官**：会不会出现写入后读不到的情况

  **我**：不会，先读 read map，再读 dirty map

  **面试官**：什么情况下，dirty map 变成 read map

  **我**：（想了一下）当 read map 未命中次数达到阈值的时候

  **面试官**：那转换的时候，会不会出现并发安全问题

  **我**：（我后面讲错方向了，他也没说）不会，因为 sync.Map key-value 的 value 是一个封装的 struct，有三种状态，nil 和 （没说出来。。。），而且修改是通过原子操作来实现的。

  {{< admonition info "面后复习反思" true >}}
  1. sync.Map 的底层结构  
    * 两个 map，dirty 所有的 key，read map 一部分的 key  
    * dirty map 读写互斥，read map 读并发，写是通过原子操作（如何原子操作，讲一下是 map 中 key-value 中 value 是一个 struct 里面有一个 pointer，CAS 这个 pointer）  
  2. 什么情况下，dirty map 转化成 read map，如何转化  
    * 当 read map 未命中次数达到阈值的时候  
    * 直接 atomic.Store()  
  3. 转换的时候会不会并发，出现写入读不到的情况（就是查 read 没有，去查 dirty 时，另一个 G 把 dirty 为 nil， read = dirty）  
    我看源码，应该是：  
    通过常用的 double check，获取 dirty 互斥锁后，再检查一下 read map 中有没有，有直接返回，没有则查 dirty map
  {{< /admonition >}}

### 一道程序题目

n 个 goroutine 顺序输出 1-100

eg：  
2 个 goroutine：   
goroutine 0 ： 1  
goroutine 1 ： 2  
goroutine 0 ： 3  

* 我的不优雅做法

  虽然结果是正确的，但实际不是面试官想要的方式。只要 sleep 稍微少一点，就会因为调度的问题导致结果不正确。

  ```go
    package main

    import (
    	"fmt"
    	"time"
    )

    func run(i int, c chan int) {
    	for {
    		n, is := <- c
    		if is {
    			fmt.Printf("goroutine %d : %d\n", i, n)
    		}

    	}

    }

    func main() {
    	n := 0
    	fmt.Scan(&n)
    	s := make([]chan int, n)
    	for i := 0; i < n; i++ {
    		s[i] = make(chan int, 1)
    		go run(i, s[i])
    	}

    	for i := 0; i < 100; i++ {
    		s[i%n] <- i+1
    		time.Sleep(time.Microsecond*800)
    	}
    }
  ```

* 面试官说我是用 chan 来控制顺序，但可以直接用 chan 作为 n 个 goroutine 通信，完成了就通知下一个。

  ```go
    package main

    import (
    	"fmt"
    	"time"
    )

    var n int

    func run(i int, c []chan int) {
    	for {
    		var count int
    		count, ok := <- c[i]
    		if !ok {
    			break
    		}

    		fmt.Printf("goroutine %d : %d\n", i, count)

    		if count == 100 {
    			for i := range c {
    				close(c[i])
    			}
    			break
    		}

    		// 通知下一个 G
    		c[(i+1)%n] <- count+1
    	}
    }

    func main() {
    	fmt.Scan(&n)
    	s := make([]chan int, n)
    	for i := 0; i < n; i++ {
    		s[i] = make(chan int, 1)
    		go run(i, s)
    	}

    	s[0] <- 1
    	time.Sleep(time.Second)
    }
  ```

{{< admonition info "面后复习反思" true >}}
写代码的程序，不急着写，一定要先思考明白，然后跟面试官交流思路，最后再动手写。
{{< /admonition >}}

### 反问环节

* 问了面试官说是不是不太重视轮子项目（没问到轮子项目）

  **面试官**：时间有限，觉得定时器项目较难，就挑这个问。

* 说我感觉到达一个瓶颈，分布式比较难学和应用，有什么推荐不？

  **面试官**：问我复变函数还有啥有学不（我说没有。。。），他说这个是基础。然后说先学理论知识，mit6.824，Raft。然后说 Raft 也就 13 年才诞生，资料会比较少，多看文章（指的是论文？）

## 面试总结

* Go 基础   
  这一方面是没问题的，但是组织表述有问题，需要**多练如何表达和抓重点**，特别是要**揣摩面试官出的题目的目的和他想要的答案**，只讲关键的一部分即可。  
  多练习把，多看面经，看面经的时候，要自己用嘴念出来，不能只看，觉得简单就不念出来。

* 项目场景问题  
  * 这方面确实很匮乏，也不知道从何下手。    
  * 而且回答这些问题，需要**考虑清楚再做出回答**，可能多种情况需要考虑。

* 写程序
  * 一定要**想清楚再写**  
  * 想清楚后**跟面试官说下思路**后再开始写

* 自我介绍  
  上面说了，需要后面再组织以下

* 反问  
  不能只问关于自己的问题，要**多多问问公司的情况**，这样才能表示出我拥有很想去的意愿

## End

最后推荐一个汇总面试记录的好助手：**飞书文档**

{{< image src="/images/记第一次面试/飞书文档.png" width=100% height=100% caption="飞书文档" >}}

写完已经快接近 3 点罗，后天考算法，大大大后天考计网和概率论。时间紧迫，但还是觉得有必要把面试总结一些，等考完试再重试试着回答一下，看会不会更好一点。